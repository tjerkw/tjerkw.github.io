---
layout: null
---
<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:cc="http://cyber.law.harvard.edu/rss/creativeCommonsRssModule.html">
    <channel>
        <title><![CDATA[Stories by Tjerk Wolterink on Medium]]></title>
        <description><![CDATA[Stories by Tjerk Wolterink on Medium]]></description>
        <link>https://medium.com/@tjerkw?source=rss-cddf17237cf1------2</link>
        <image>
            <url>https://cdn-images-1.medium.com/fit/c/150/150/0*B1h40waHw0m5DiDH.jpg</url>
            <title>Stories by Tjerk Wolterink on Medium</title>
            <link>https://medium.com/@tjerkw?source=rss-cddf17237cf1------2</link>
        </image>
        <generator>Medium</generator>
        <lastBuildDate>Mon, 20 May 2019 21:45:10 GMT</lastBuildDate>
        <atom:link href="https://medium.com/feed/@tjerkw" rel="self" type="application/rss+xml"/>
        <webMaster><![CDATA[yourfriends@medium.com]]></webMaster>
        <atom:link href="http://medium.superfeedr.com" rel="hub"/>
        <item>
            <title><![CDATA[The Future of Software Engineering: Model Driven Engineering]]></title>
            <link>https://medium.com/@tjerkw/the-future-of-software-engineering-model-driven-engineering-5785dd956e4d?source=rss-cddf17237cf1------2</link>
            <guid isPermaLink="false">https://medium.com/p/5785dd956e4d</guid>
            <category><![CDATA[software]]></category>
            <category><![CDATA[programming]]></category>
            <category><![CDATA[model-driven-engineering]]></category>
            <category><![CDATA[eclipse]]></category>
            <dc:creator><![CDATA[Tjerk Wolterink]]></dc:creator>
            <pubDate>Mon, 19 Apr 2010 22:07:39 GMT</pubDate>
            <atom:updated>2017-09-21T10:40:36.913Z</atom:updated>
            <content:encoded><![CDATA[<p>In this first article I will cover Model Driven Engineering (MDE , also called Domain Driven Design DDD) and briefly explain the core concepts of MDE. MDE is a relatively new research field in software engineering, the first ideas are from research papers in the end of the 20th century. A lot of research is done in the last decade and it has become more prevalent in the software industry.</p><p>First some of the problems that MDE tries to tackle are discussed. After that the core concepts of MDE are covered. The article will end with some applications of MDE.</p><h3>What MDE Tries to Solve</h3><p>As a programmer you may not notice this on a first glance, but there are some basic problems with the current programming approaches. The <em>holy grail of software engineering</em> is to perform software development in a similar way to how they do it in mechinical engineering: create a model of your software, check that model for failures and use that model as a blueprint for actually creating your product. Lets look at the problems we have in achieving that goal.</p><h3>The gap between Problem Domain and Implementation</h3><p>Software is written to achieve a certain goal for a certain domain. This domain is called the <em>problem domain</em>. Examples of such domains are banking, healthcare, social network etc etc. The goals are made explicit by a joint effort between the domain experts and software developers in some kind of requirements document. These requirements are mostly specified in human readable text and refer to concepts in the problem domain. It is the task of the development team to implement the software given the requirements.</p><p>The problem here is that the solution to the problem (the implementation) is expressed in a (relatively low level) programming language, which only provides <em>algorithmic concept</em>s. The requirements, on the other hand, are specified ambigously in text using problem <em>domain concept</em>s. This makes it difficult to check if your requirements are met. It would be easier if we could express the solution, or even the requirements themselves, in a model which refers to concepts related to our problem domain. The solution that MDE provides is the ability to create intermediate languages in which one can use problem domain concepts to specify a model. Or as Douglas C. Smith puts it:</p><p><em>“Model-driven engineering technologies offer a promising approach to address the inability of third-generation languages to alleviate the complexity of platforms and express domain concepts effectively.”</em></p><h3>Dealing with Software Evolution</h3><p>Change is a major factor in software systems, requirements change, personnel leave and join, and even the software/deploy platforms change over time. When requirements change the software is out of sync and also needs to be changed. When new programmers join the company they have to understand code written by someone else. A change to a new software platform may require a complete rewrite of the implementation!</p><p>Again the solution that MDE proposes is the use of higher level models. These higher level models are closer to the problem domain, smaller then the implementation and with no boilerplate code. The model is platform independend, easier to understand and therefere it copes better with change.</p><h3>Model Driven Engineering Concepts</h3><p>While not all problems MDE solves are discussed we move onto the real deal: MDE itself. In this section the MDE approach is discussed briefly to give you a glimpse into the future of software development!</p><h3>The Unifying Power of Models</h3><p>The major corner stone of MDE are models. Without going into much detail you can view a model as a representation of system written in a certain modelling language. In MDE any software artifact is viewed as a model. This may be a code, but also requirements are specified as a model. All models conform to a metamodel. Suppose we have a model written in a modelling language A, then that model will conform to the metamodel of the language A. This is similar to how a C++ program (the model) conforms to the C++ specification (the metamodel). Or how an XML document (model) conforms to an XMLSchema (metamodel). Or how a BNF syntax specification (model) conforms to BNF (metamodel). This is visualised in the diagram below.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/960/0*M14uYGk3v4efwFpx." /></figure><p>The 3 Layers in MDE</p><p>The diagram also shows the metametamodel layer, which is out of the scope of this article. But let’s just say that the metametamodel has a nice property: it is defined in itself (for example <a href="http://www.w3.org/2001/XMLSchema.xsd">xmlschema defined in xmlschema</a>).</p><p>The concept of model might look a bit vague at this point. It may look like just a cosmetic change: what we call a <em>program</em> is called in model in MDE. This is partially true. A program may be a model, but a model does not have to be a program. For example the data in google maps provides a partial model of the world, this however can not be seen as a program. Also a model does not have to be textual like most programming languages. A model is a logical entity and it can be edited visually or textually depending on the MDE framework you use. For now one can see a model as some kind of annotated <a href="http://en.wikipedia.org/wiki/Graph_(mathematics)">graph</a>.</p><h3>Increasing the Level of Abstraction</h3><p>Abstraction is an important concept in computer science. Developers and researchers used abstractions to <em>express their programs in terms of their design instead of the underlying computer technology</em> (assembly, c, c++, php, sql, java etc). This shielded them from the complexity of those underlying platforms. Again MDE takes a similar path, it too increases the level of abstraction.</p><p>Currently most software projects are written in <em>general purpose programming language (GPLs). </em>As explained in the problem section these language are not close to the problem domain. A solution that to this problem is the use of <em>domain specific languages (DSLs). </em>Current GPLs are language like Java, C++ and PHP while DSLs are languages like SQL, Excel, HTML. The problem with DSL’s is that they are limited and not easy to create.</p><p>An ideal DSL is a language that fits your problem domain perfectly. Here is where the main power of MDE comes in: it allows one to a create DSL very easily using your own domain concepts. The DSL can then be use to create models which are closer to your problem domain. These models can then in turn be used to define your final implementation.</p><p>Bridging the requirements gap</p><h3>Code Generation</h3><p>An attentive reader might think: so where is the actual code/implementation? The most used approach is to write a <em>code generator</em> which generates GPL code from your DSL model. If the model changes new code can be generated. However if the DSL metamodel changed the code generator also has to be changed to generate new code. This is actually how it is often done in most industry applications today. Maintaining your code generator may seem like a disadvantage. However if your DSL is good enough the code generator only has to built once for each target platform. The rate of change of a well designed DSL is also low compared to the rate of change of your DSL, therefore the code generator does not have to change that often.</p><p>Code generation is nothing new. For example when you compile your C++ application it basically generates a low level model (opcodes) from your high level model (your program). A database management system translates (generates) your SQL query to <a href="http://en.wikipedia.org/wiki/Relational_algebra">relational algebra</a>, optimizes it, and executes code to retrieve the data. XML Data is fed into an XSLT stylesheet to generate a website / digital print etc. MDE basically provides a framework on a higher level.</p><p>Another approach is to make your DSL executable. This is a more theoretical approach; one has to define the <a href="http://en.wikipedia.org/wiki/Formal_semantics_of_programming_languages">semantics</a> of your DSL formally. This approach is currently under heavy research. In fact <a href="http://essay.utwente.nl/59094/">my master thesis</a> was about this approach.</p><h3>Model Checking, Model Transformations and More</h3><p>Another important advantages of MDE is that it allows certain rigorous mathematical techniques to be applied on it. For example <a href="http://en.wikipedia.org/wiki/Model_checking">model checking</a> can be applied on a model of the software. In this sense MDE brings us closer to the holy grail of software engineering: 100% bug free software!</p><p>There are other advantages of having models as artifacts: we can transform models to other models using <em>model transformation. </em>Suppose we could generate an initial software model from the requirements model. Using model transformation we could trace how a certain change of a requirement impacts the software model, this is called <em>impact analysis.</em></p><h3>Applications</h3><p>MDE can basically be used in any software project. However its main benefit is prevalent in bigger software projects with multiple stakeholders. A short list of concrete applications is given below to give the reader some concrete examples:</p><ul><li>Usage in data centric applications: The model describes the data, constraints, relationships and workflow. The implementation (a web applicaton) could be generated from this model. Forms, form validation, SQL Code, correct control flow, etc are all generated from your domain model.</li><li>Usage in function critical applications: A model is needed to perform model checking.</li><li>Mobile Application Development: writing the same application for multiple platforms proves difficult due to the differences between the platforms. A DSL provides one language for all platforms.</li></ul><p>Most applicatons of MDE are domain specific and therefore only used by a certain company or in a certain domain. Therefore it is difficult to give some real world examples.</p><p>MDE basically raises the level of abstraction as has happened always in computer science. It is fairly new and of course time has to tell if it succeeds. However its goal is ambitious: it provides a solution to the growing complexity of software systems and takes a big step from moving from programming to mature <em>software engineering</em>.</p><p>MDE itself is maturing. MDE is used more and more in practice. Big companies are adopting it (for example ASML, Microsoft, Motorola, SAP, Ordina, Atos Origin and IBM). And also tool support becoming better and better (for example: <a href="http://www.eclipse.org/modeling/">Eclipse EMF</a>).</p><p>Below are some references if you want to continue reading:</p><ul><li>Model-Driven Engineering, Douglas C. Smith, <a href="http://www.cs.wustl.edu/~schmidt/GEI.pdf">http://www.cs.wustl.edu/~schmidt/GEI.pdf</a></li><li>Graph (mathematics), Wiki Article, <a href="http://en.wikipedia.org/wiki/Graph_(mathematics)">http://en.wikipedia.org/wiki/Graph_(mathematics)</a></li><li>Applying SOS to MDE, Tjerk Wolterink, University of Twente, 2009, <a href="http://essay.utwente.nl/59094/">http://essay.utwente.nl/59094/</a></li><li>The Eclipse Modelling Project, <a href="http://www.eclipse.org/modeling/">http://www.eclipse.org/modeling/</a></li><li>Presentation: Developing DSL’s with Eclipse, Peter Friese, <a href="http://wiki.eclipse.org/Eclipse_Day_At_Googleplex_2009/Session_Abstacts#Developing_DSLs_with_Eclipse">http://wiki.eclipse.org/Eclipse_Day_At_Googleplex_2009/Session_Abstacts#Developing_DSLs_with_Eclipse</a></li><li>Presentation: An Introduction To Domain Specific Languages, <a href="http://www.infoq.com/presentations/domain-specific-languages">http://www.infoq.com/presentations/domain-specific-languages</a></li><li>10 Reasons why you should start with MDE, Johan den Haan, <a href="http://www.theenterprisearchitect.eu/archive/2009/11/25/15-reasons-why-you-should-start-using-model-driven-development">http://www.theenterprisearchitect.eu/archive/2009/11/25/15-reasons-why-you-should-start-using-model-driven-development</a></li></ul><p><em>Originally published at </em><a href="https://tjerktech.wordpress.com/2010/04/19/the-future-of-software-engineering-model-driven-engineering/"><em>tjerktech.wordpress.com</em></a><em> on April 19, 2010.</em></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=5785dd956e4d" width="1" height="1">]]></content:encoded>
        </item>
    </channel>
</rss>
